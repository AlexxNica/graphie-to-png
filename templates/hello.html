{% extends 'layout.html' %}

{% block head %}
{{super()}}
<style type="text/css" media="screen">
    body {
        font: 14px "Helvetica Neue", Helvetica, Arial, sans-serif;
        min-width: 1030px;
    }
    #left {
        float: left;
        margin-right: 10px;
        outline: 1px solid #ccc;
        width: 520px;
    }
    #editor {
        height: 600px;
        border-bottom: 1px solid #ccc;
    }
    #samples {
        display: none;
    }
    #output {
        float: left;
        min-height: 610px;
        outline: 1px solid #ccc;
        width: 480px;
        padding: 10px;
    }
    #output .graphie {
        outline: 1px dashed #df0030;
    }
    #output .error {
        font: 12px Menlo, Courier, monospace;
        color: red;
    }
    #output .size {
        font-size: 12px;
        color: #df0030;
        display: block;
        margin-top: 3px;
    }
    form.form-create-png {
        display: inline;
    }
</style>
{% endblock head %}

{% block content %}
<div id="left">

<div id="editor"></div>

<script id="grid-setup-pre" type="text/graphie">
// X and Y ranges of the graph
var X_RANGE = [-10, 10];
var Y_RANGE = [-10, 10];

// var STEP = [<x tick step>, <y tick step>];
// var STEP = [10, 25];
var STEP = "auto";

// Width of the graph in pixels
// Let's use 400 for "normal" graphs and 170 for "small" graphs
var SIZE = 400;

var xScale;
var yScale;
setup();
//////////////////////////////////////////////////////////////

</script>

<script id="grid-setup-post" type="text/graphie">

//////////////////////////////////////////////////////////////
// Setup grid, ticks, and labels and initialize graph.
function setup() {
    var dimensions = [SIZE, SIZE];
    var range = [X_RANGE, Y_RANGE];
    var step = STEP;
    if (step === "auto") {
        step = _.map(range, function(extent, i) {
            return Perseus.Util.tickStepFromExtent(
                    extent, dimensions[i]);
        });
    }
    var gridConfig = _.map(range, function(extent, i) {
        return Perseus.Util.gridDimensionConfig(
                step[i],
                extent,
                dimensions[i]);
    });
    var scale = _.pluck(gridConfig, "scale");
    xScale = scale[0];
    yScale = scale[1];
    var paddedRange = _.map(range, function(extent, i) {
        var padding = 25 / scale[i];
        return [extent[0], extent[1] + padding];
    });
    graphInit({
        gridRange: range,
        range: paddedRange,
        scale: scale,
        axisArrows: "<->",
        labelFormat: function(s) {
            return "\\small{" + s + "}";
        },
        gridStep: _.pluck(gridConfig, "gridStep"),
        tickStep: _.pluck(gridConfig, "tickStep"),
        labelStep: 1,
        unityLabels: _.pluck(gridConfig, "unityLabel")
    });
    style({
        clipRect: [[X_RANGE[0], Y_RANGE[0]],
                [X_RANGE[1] - X_RANGE[0],
                Y_RANGE[1] - Y_RANGE[0]]]
    });

    label([0, Y_RANGE[1]], "y", "above");
    label([X_RANGE[1], 0], "x", "right");
}

</script>

<script id="simple-setup-pre" type="text/graphie">
/* The X and Y ranges of this canvas */
var range = RANGE;

/* The output's largest side is limited to this many pixels */
var size = 400;

setup();
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
</script>

<script id="simple-setup-post" type="text/graphie">
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
function setup() {
    var scales = _.map(range, function(extent) {
        return Perseus.Util.scaleFromExtent(extent, size);
    });
    init({range: range, scale: _.min(scales)});
}

</script>

<div id="samples">
<script type="text/graphie" data-title="0. Blank page"></script>

<script type="text/graphie" data-use-grid="true" data-title="1. Simple plot">
style({
    stroke: BLUE,
    fill: "none"
});

plot(function(x) {
    // Write down the function you want to plot here
    return -0.5 * x * x + 2 * x + 3.0;
}, X_RANGE);
</script>

<script type="text/graphie" data-use-grid="true" data-title="2. Piecewise function">
style({
    stroke: BLUE,
    fill: "none"
});

plot(function(x) {
    return -0.5 * x * x + 2 * x + 3.0;
}, [-10, 3]);

plot(function(x) {
    return x - 7.0;
}, [3, 10]);

ellipse([3, 4.5], [4 / xScale, 4 / yScale], {fill: BLUE});
ellipse([3, -4], [4 / xScale, 4 / yScale], {fill: "white"});
</script>


<script type="text/graphie" data-use-grid="true" data-title="3. Parametric plots">
style({
    stroke: BLUE,
    fill: "none"
});

plotParametric(function(t) {
    // Write down the function you want to plot here as [x, y] in terms of t
    return [4, t];
}, Y_RANGE);

style({
    stroke: GREEN,
    fill: "none"
});

plotParametric(function(t) {
    // Write down the function you want to plot here as [x, y] in terms of t
    return [t + 2 * cos(t), 2 * sin(t)];
}, [-12, 12]);
</script>


<script type="text/graphie" data-title="4. Triangle (old)">
var triangle = solveTriangle({
    sides: [13, 14, 15],
    angles: [null, null, null],
    sideLabels: ["a", "b", "c"],
    angleLabels: ["25^\\circ", null, null],
    vertexLabels: ["A", "B", "C"],

    xPos: 1,
    yPos: 1,
    width: 10,
    height: 6,
    rot: 0
});

triangle = addTriangle(triangle);
init({
    range: [[0, triangle.width + 2], [0, triangle.height + 2]]
});

triangle.draw();
</script>

<script type="text/graphie" data-title="5. Tape diagram">

// Top label for the entire tape
var TOP_LABEL = "\\text{Original Price}";

// Labels for each division. Add as many divisions as you like
var LABELS = [
        "20\\%",
        "20\\%",
        "20\\%",
        "20\\%",
        "20\\%",
    ];

// Label for the left partition
var BOT_LEFT_LABEL = "\\text{Sale Price}";

// Number of divisions in the left partition
var BREAK = 4;

// Label for the right partition
var BOT_RIGHT_LABEL = "$5";

///////////////////////////////////////////////////////////

var scale = 40;
init({
    range: [[-0.1, 10.1], [0, 4]],
    scale: scale
});

style({ stroke: BLUE });

var fullWidth = 10;
var half = fullWidth / 2;

var boxWidth = fullWidth / LABELS.length;
_.each(LABELS, function(lbl, n) {
    path([[boxWidth * n, 1.5], [boxWidth * (n + 1), 1.5],
          [boxWidth * (n + 1), 2.5], [boxWidth * n, 2.5], true]);
    label([boxWidth * (n + 0.5), 2], lbl);
});

var br = BREAK / LABELS.length;
var pad = 2 / scale;
var topY = 2.8;
var top = curlyBrace([pad, topY], [fullWidth - pad, topY]);

var bottomY = 0.9;
var bottomLeft = curlyBrace([br * fullWidth - pad, bottomY], [pad, bottomY]);
var bottomRightPts = [
    [fullWidth - pad, bottomY],
    [br * fullWidth + pad, bottomY]
];
var bottomRight = curlyBrace(bottomRightPts[0], bottomRightPts[1]);


_.each([top, bottomLeft, bottomRight], function (brace) {
    brace.attr({ stroke: GRAY, "stroke-width": 1.5 });
});

label([half, 3.1], TOP_LABEL, "above");
label([half * br, 0.9], BOT_LEFT_LABEL, "below");
label([half * br + half, 0.9], BOT_RIGHT_LABEL, "below");
</script>


<script type="text/graphie" data-title="6. Area model">
var CHART = [
        // Number, fill color, stroke color, shaded
        [[2, 3], [BLUE, null], [null, GRAY], [true, false]],
        [[4, 6], [BLUE, GRAY]],
        [ ],
        [[1, 1, 1, 1, 1], [RED, ORANGE, GREEN, BLUE, PINK ]]
    ];


init({
    range: [[0, 1], [0, CHART.length]],
    scale: [400,30]
});

_.each(CHART.reverse(), function(row, n) {
    if (row.length) {
        rectchart(row[0], row[1], n, row[2], row[3]);
    }
});
</script>

<script type="text/graphie" data-title="7. Number line">
var RANGE = [-5, 10];
var TICK_STEP = 1;
var LABEL_TICKS = true;

var LABELS = [
    {
        value:      0,
        text:       "0",
        position:   "below",
        color:      BLUE
    },
    {
        value:      5,
        text:       "x",
        position:   "above",
        color:      BLACK
    },
];

var HIGHLIGHTED_TICKS = [
    [ 0, BLUE ],
];

var POINTS = [
    [ 2, RED ],
]

var CIRCLES = [
    [ -4, RED ],
]

var ARROWS = [
    [ 2, 12, RED ],
    [ -4, -7, RED ],
]

///////////////////////////////////////////////////////////////

var SCALE = 400 / (RANGE[1] - RANGE[0]);

init({
    range: [[RANGE[0] - (30 / SCALE), RANGE[1] + (30 / SCALE)],
            [-1, 1]],
    scale: [SCALE, 40]
});

var minusIgnorer = function(a) {
    return (a + "").replace(/-(\d)/g, "\\llap{-}$1");
};

line([RANGE[0] - (25 / SCALE), 0],
     [RANGE[1] + (25 / SCALE), 0], {
    arrows: "->"
});

line([RANGE[1] + (25 / SCALE), 0],
     [RANGE[0] - (25 / SCALE), 0], {
    arrows: "->"
});

for (var x = RANGE[0]; x <= RANGE[1];
        x = roundTo(10, x + TICK_STEP)) {
    line([x, -0.2], [x, 0.2]);
    if (LABEL_TICKS && !_.findWhere(LABELS,
            {value: x, position: "below"})) {
        label([x, -0.53],  minusIgnorer(x), "center");
    }
}

if (typeof(LABELS) !== "undefined") {
    _.each(LABELS, function(lbl) {
        if (lbl.position === "above") {
            label([lbl.value, 0.53],  minusIgnorer(lbl.text),
                    "center", {
                color: lbl.color
            });
        } else {
            label([lbl.value, -0.53],  minusIgnorer(lbl.text),
                    "center", {
                color: lbl.color
            });
        }
    });
}

if (typeof(HIGHLIGHTED_TICKS) !== "undefined") {
    _.each(HIGHLIGHTED_TICKS, function(tick) {
        line([tick[0], -0.2], [tick[0], 0.2], {
            stroke: tick[1],
            strokeWidth: 3.5
        });
    });
}

if (typeof(ARROWS) !== "undefined") {
    _.each(ARROWS, function(arrow) {
        arrow[0] = min(arrow[0], RANGE[1] + (26 / SCALE));
        arrow[0] = max(arrow[0], RANGE[0] - (26 / SCALE));
        arrow[1] = min(arrow[1], RANGE[1] + (26 / SCALE));
        arrow[1] = max(arrow[1], RANGE[0] - (26 / SCALE));
        line([arrow[0], 0 ], [arrow[1], 0], {
            arrows: "->",
            stroke: arrow[2],
            strokeWidth: 3.5
        });
    });
}

if (typeof(POINTS) !== "undefined") {
    _.each(POINTS, function(point) {
        ellipse([point[0], 0],
                [5 / (400 / (RANGE[1] - RANGE[0])), 5 / 40], {
            fill: point[1],
            stroke: null
        });
    });
}

if (typeof(CIRCLES) !== "undefined") {
    _.each(CIRCLES, function(point) {
        ellipse([point[0], 0],
                [5 / (400 / (RANGE[1] - RANGE[0])), 5 / 40], {
            fill: BACKGROUND,
            stroke: point[1],
            strokeWidth: 3
        });
    });
}
</script>

<script type="text/graphie" data-title="8. Place value blocks">
var NUMBER = 123;
var SHOW_LABELS = true;

//////////////////////////////////////////////////////////////

var thousands = floor(NUMBER / 1000)
var hundreds = floor(NUMBER % 1000 / 100)
var tens = floor(NUMBER % 100 / 10)
var ones = NUMBER % 10

var yMax = max(ones + 1.5,
               tens > 0 ? 11.5 : 0,
               hundreds > 0 ? 11.5 : 0,
               thousands > 0 ? 16.5 : 0);

init({
    range: [[0, 3 + (tens * 2) + (hundreds * 11) +
            (thousands * 16)],
            [SHOW_LABELS ? -1 : 0, yMax]],
    scale: [20, 20]
});

var drawCube = function(x, y) {
    path([[x, y + 1],  [x, y], [x + 1, y], [x + 1.5, y + 0.5],
        [x + 1.5, y + 1.5], [x + 0.5, y + 1.5], true]);
    path([[x, y + 1], [x + 1, y + 1], [x + 1, y]]);
    path([[x + 1, y + 1], [x + 1.5, y + 1.5]])
};

style({ fill: "#b2c7ed", stroke: BLUE })

var xPos = 0.5;

_.times(thousands, function(n) {
    _.times(10, function(z) {
        _.times(10, function(y) {
            _.times(10, function(x) {
                if (x === 9 || y === 9 || z === 9) {
                    drawCube(5 + (z * -0.5) + x + xPos +
                        (n * 15.5), 4.5 + (z * -0.5) + y + 0.5);
                }
            });
        });
    });
    if (SHOW_LABELS) {
        label([xPos + (n * 15.5) + 5, -0.2], "1000");
    }
});

xPos += thousands * 15.5 + 0.5;

_.times(hundreds, function(n) {
    _.times(10, function(y) {
        _.times(10, function(x) {
            drawCube(x + xPos + (n * 11), y + 0.5);
        });
    });
    if (SHOW_LABELS) {
        label([xPos + (n * 11) + 5, -0.2], "100");
    }
});

xPos += hundreds * 11;

_.times(tens, function(n) {
    _.times(10, function(y) {
        drawCube(xPos + (n * 2), y + 0.5);
    });
    if (SHOW_LABELS) {
        label([xPos + (n * 2) + 0.5, -0.2], "10");
    }
});

xPos += tens * 2;

_.times(ones, function(y) {
    drawCube(xPos, y + 0.5);
});
if (SHOW_LABELS && ones > 0) {
    label([xPos + 0.5, -0.2], ones);
}
</script>

<script type="text/graphie" data-title="9. Trigonometric function">
// X and Y ranges of the graph
var X_RANGE = [-PI, 2.5 * PI];
var Y_RANGE = [-3, 3];

// var STEP = [<x tick step>, <y tick step>];
// var STEP = [10, 25];
var STEP = "auto";

// Width of the graph in pixels
// Let's use 400 for "normal" graphs and 170 for "small" graphs
var SIZE = 400;

var xScale;
var yScale;
setup();
//////////////////////////////////////////////////////////////


style({
    stroke: BLUE,
    fill: "none"
});

plot(function(x) {
    // Write down the function you want to plot here
    return sin(x);
}, X_RANGE);


//////////////////////////////////////////////////////////////
// Setup grid, ticks, and labels and initialize graph.
function setup() {
    var dimensions = [SIZE, SIZE];
    var range = [X_RANGE, Y_RANGE];
    var step = STEP;
    if (step === "auto") {
        xs = Perseus.Util.tickStepFromExtent(
                [range[0][0] / PI, range[0][1] / PI],
                dimensions[0]);
        ys = Perseus.Util.tickStepFromExtent(
                range[1], dimensions[1]);
        step = [xs * PI, ys];
    }
    var gridConfig = _.map(range, function(extent, i) {
        return Perseus.Util.gridDimensionConfig(
                step[i],
                extent,
                dimensions[i]);
    });
    var scale = _.pluck(gridConfig, "scale");
    xScale = scale[0];
    yScale = scale[1];
    var paddedRange = _.map(range, function(extent, i) {
        var padding = 25 / scale[i];
        return [extent[0], extent[1] + padding];
    });
    graphInit({
        gridRange: range,
        range: paddedRange,
        scale: scale,
        axisArrows: "<->",
        labelFormat: function(s) {
            return "\\small{" + s + "}";
        },
        gridStep: _.pluck(gridConfig, "gridStep"),
        tickStep: _.pluck(gridConfig, "tickStep"),
        labelStep: 1,
        unityLabels: _.pluck(gridConfig, "unityLabel"),
        xLabelFormat: piFraction
    });
    style({
        clipRect: [[X_RANGE[0], Y_RANGE[0]],
                [X_RANGE[1] - X_RANGE[0],
                Y_RANGE[1] - Y_RANGE[0]]]
    });

    label([0, Y_RANGE[1]], "y", "above");
    label([X_RANGE[1], 0], "x", "right");
}
</script>


<script type="text/graphie" data-title="10. Arrow table">
// Rows for table are of the form
//
//  [["Label-1", "Label-2", ..., "Label-N"], "Arrow label"]
//
// Note: if arrow label is set to "" no arrow will be drawn.
var TABLE = [
    [["\\textbf{percent}",  "\\textbf{dollars}"],   ""],
    [["100\\%",             "\\$140"],              "{} \\div 5"],
    [["20\\%",              "\\$28"],               "{} \\times 6"],
    [["100\\%",             "\\$168"],              ""]
];

// If arrow labels don't fit within red square increase this
var sideGap = 2;
////////////////////////////////////////////////////////////////


var height = TABLE.length;
var dWidth = 3;
if (TABLE[0][0].length === 1) {
    var width = 1 + 2 * sideGap;
} else {
    var width = 1 + 2 * sideGap + dWidth * (TABLE[0][0].length - 1);
}
var scale = 40;

init({
    range: [[-0.1, width + 0.1], [-0.1, height + 0.1]],
    scale: scale
});

style({
    strokeWidth: 1
});


var y = 0.5;
_.each(TABLE.reverse(), function(row) {
    _.each(row[0], function(cell, c) {
        if (c === 0) {
            label([sideGap + 0.5, y], cell);
        } else {
            var x = 1 + sideGap + dWidth * (c - 1);
            label([x + 1, y], "\\longrightarrow");
            label([x + 2.5, y], cell);
        }
    });

    if (row[1].length > 0) {
        var pad = 0.3;
        var labelPad = pad + 0.9;
        var x = 1 + dWidth * (row[0].length - 1);
        var labelY = y - 0.5;
        var arrowRadius = 0.4;

        curvyArrow([sideGap - pad, labelY], arrowRadius, "left", false);
        curvyArrow([x + sideGap + pad, labelY], arrowRadius, "right", true);

        label([sideGap - labelPad, labelY], row[1]);
        label([x + sideGap + labelPad, labelY], row[1]);
    }

    y++;
});
</script>


<script type="text/graphie" data-title="11. Pie chart">
// CHART is a list of piecharts. Each row has format:
// [
//      [list of pie pieces with...],
//      [these associated colors],
//      radius,
//      translation,
//      stroke color  // optional
// ]
var CHART = [
    [[2, 3], [BLUE, GRAY], 60, [100, 0]],
    [[4, 6], [BLUE, GRAY], 100, [-90, 0]],
    [[1, 1, 1, 1, 1], [GREEN, GRAY, PURPLE, RED, BLUE], 40, [30, -100], BLACK]
];


///////////////////////////////////////////////

var boundingBoxes = _.map(CHART, function (row) {
    var coords = row[3];
    var x = coords[0];
    var y = coords[1];
    var radius = row[2];
    return [x - radius, x + radius, -y - radius, -y + radius];
});

var pad = 3;
var minX = _.min(_.pluck(boundingBoxes, 0)) - pad;
var maxX = _.max(_.pluck(boundingBoxes, 1)) + pad;
var minY = _.min(_.pluck(boundingBoxes, 2)) - pad;
var maxY = _.max(_.pluck(boundingBoxes, 3)) + pad;

init({
    range: [[minX, maxX], [minY, maxY]],
    scale: 1
});

_.each(CHART, function(row, n) {
    var tr = row[3];
    var color = row[4];
    piechart(row[0], row[1], row[2], color).translate(tr[0], tr[1]);
});

</script>

<script type="text/graphie" data-title="12. Area model 2">
// The total width is the sum of these plus 70, so keep the sum of
// these to no more than 410.
var WIDTHS = [210, 130, 70];
var HEIGHTS = [
    130,
    70
];

var COLORS = [
    [PURPLE, BLUE, ORANGE],
    [GREEN, RED, GRAY]
];

var INNER_LABELS = [
    ["800 \\times 40", "a \\times 40", "5 \\times 40"],
    ["800 \\times b", "a \\times b", "5 \\times b"],
];

var SHADED = [
    [false, false, false],
    [false, false, false]
];

var TOP_LABELS = ["800", "+", "a", "+", "4"];
var LEFT_LABELS = ["40", "+", "b"];
var RIGHT_LABELS = ["{}+16", "", ""];

////////////////////////////////////////////////////////////////


init({
    range: [
        [-30, sum(WIDTHS) + 40],
        [-sum(HEIGHTS), 30]],
    scale: [1, 1]
});

style({
    fillOpacity: 0.5,
    stroke: BACKGROUND
})

_.each(COLORS, function(row, j) {
    _.each(row, function(color, i) {
        if (!color) {
            return;
        }
        style({ fill: color });
        nrect(sum(WIDTHS, 0, i), -sum(HEIGHTS, 0, j), WIDTHS[i], -HEIGHTS[j]);
    });
});

style({fillOpacity: 1.0});

_.each(INNER_LABELS, function(row, j) {
    _.each(row, function(text, i) {
        if (!text) {
            return;
        }
        label([sum(WIDTHS, 0, i + 1) - WIDTHS[i] / 2, -(sum(HEIGHTS, 0, j + 1) - HEIGHTS[j] / 2)], text);
    });
});

_.each(TOP_LABELS, function(text, i) {
    var ii = Math.floor((i + 1) / 2);
    if (i % 2 === 0) {
        label([sum(WIDTHS, 0, ii + 1) - WIDTHS[ii] / 2, 15], text);
    } else {
        label([sum(WIDTHS, 0, ii), 15], text);
    }
});

_.each(LEFT_LABELS, function(text, i) {
    var ii = Math.floor((i + 1) / 2);
    if (i % 2 === 0) {
        label([-15, -sum(HEIGHTS, 0, ii + 1) + HEIGHTS[ii] / 2], text);
    } else {
        label([-15, -sum(HEIGHTS, 0, ii)], text);
    }
});

_.each(RIGHT_LABELS, function(text, i) {
    var ii = Math.floor((i + 1) / 2);
    if (i % 2 === 0) {
        label([sum(WIDTHS) + 20, -sum(HEIGHTS, 0, ii + 1) + HEIGHTS[ii] / 2], text);
    } else {
        label([sum(WIDTHS) + 20, -sum(HEIGHTS, 0, ii)], text);
    }
});

function nrect(x, y, w, h) {
    rect(x + min(0, w), y + min(0, h), abs(w), abs(h));
}

function sum(arr, a, b) {
    return _.reduce(arr.slice(a, b), function(x, y) {
        return x + y;
    }, 0);
}

style({
    stroke: "#000",
    strokeWidth: 2,
    strokeOpacity: 0.5,
    fillOpacity: 0,
    fill: null
});

_.each(SHADED, function(row, j) {
    _.each(row, function(shaded, i) {
        if (shaded) {
            shadeRect(sum(WIDTHS, 0, i) + min(0, WIDTHS[i]),
                    -sum(HEIGHTS, 0, j) + min(0, -HEIGHTS[j]),
                    abs(WIDTHS[i]), abs(HEIGHTS[j]), 1);

        }
    });
});
</script>

<script type="text/graphie" data-use-simple="true" data-title="13. Intro to the Drawing API">
drawLine({
    points: [[-5, 8.5], [5, 8.5]],
    showPoints: true, // whether to actually show points
    vertexLabels: ["A", "B"],
    color: BLUE // changes the color of both line and labels
});

drawSegment({
    points: [[-5, 7], [5, 7]],
    dashed: true,
    sideLabel: "x",
    stroke: GREEN // only changes the color of the line
});

drawRay({
    points: [[-5, 6], [5, 6]],
    dotted: true
});

drawRay({
    point: [-5, 5], // you can also create a ray from one point
    angle: 0,       // and an angle direction
    dashed: true,
    dotted: true
});

drawPoint({
    point: [-7, 7],
    label: "Y",
    color: PINK // changes the color of both point and labels
});

drawPoint({
    point: [7, 7],
    label: "Z",
    stroke: PURPLE, // only changes the color of the point
    fill: PURPLE    // only changes the color of the point
});

// For much more about polygons, see template #17 (Polygon)
drawPolygon({
    points: [
        [-7, 0],
        [-7, 4],
        [-4, 0]
    ],
    vertexLabels: ["A", "B", "C"],
    arcs: 1,
    sideLabels: "$len0",
    showPoints: false
});

drawCircle({
   center: [3, 0],
   radius: 3,
   color: ORANGE, // changes the color of both stroke and fill
   fillOpacity: 0.2 // all styles can be overriden
});

drawArc({
    center: [3, 0],
    radius: 2.5, // circular arc
    start: 225,
    end: 315,
    stroke: RED
});

drawEllipse({
   center: [-3, -6],
   radii: [5, 2],
   fill: ORANGE, // only changes the color of the fill
   fillOpacity: 0.2
});

drawArc({
    center: [-3, -6],
    radii: [4.5, 1.5], // elliptical arc
    start: 225,
    end: 315,
    stroke: RED,
    fill: GREEN,
    fillOpacity: 0.5
});

drawSector({ // like drawArc above, except completely outlined
    center: [6, -6],
    radii: [4.5, 1.5], // elliptical arc
    start: 225,
    end: 315,
    stroke: PINK,
    fill: BLUE,
    fillOpacity: 1
});

drawSegment({
   points: [[3, 0], [6, 0]],
   stroke: ORANGE
});

var offset = polar(3, 135); // polar coordinate (radius, angle)
var onCircle = addPoints([3, 0], offset); // sum 2+ points

drawSegment({
   points: [[3, 0], onCircle],
   stroke: ORANGE
});

drawAngleLabel({
    points: [[6, 0], [3, 0], onCircle], // in clockwise order
    label: "$deg2", // "$deg" is relaced by angle measure
    arcs: 2         // the 2 means 2 decimal places are shown
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-10, 10], [-5, 5]]" data-title="14. Angle between lines">
var a = [-1, 0],
    b = [1, 0],
    c = polar(-1, 25),
    d = polar(1, 25),
    e = [0, 0];

drawLine({
    points: [a, b]
});

drawLine({
    points: [c, d],
    color: BLUE
});

drawAngleLabel({
    points: [a, e, c],
    label: "5x",
    distance: 4,    // distance from vertex to label
    color: PINK
});

drawAngleLabel({
    points: [b, e, d],
    label: "$deg0", // $deg is replaced by actual angle measure
    distance: 4,    // the 0 means 0 decimal places are shown
    arcs: 2,
    color: PURPLE
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-2, 8], [-1, 4]]" data-title="15. Complementary angles 1">
var a = [0, 0],
    b = [1, 0],
    c = polar(1, 20),
    d = [0, 1];

drawLine({
    points: [a, b]
});

drawRay({
    points: [a, c]
});

drawRay({
    points: [a, d]
});

drawAngleLabel({
    points: [b, a, c],
    label: "2x",
    distance: 4,    // distance from vertex to label
    color: PINK
});

drawAngleLabel({
    points: [c, a, d],
    label: "$deg1", // $deg is replaced by actual angle measure
    distance: 4,    // the 1 means 1 decimal place is shown
    color: PURPLE
});

drawAngleLabel({
    points: [b, a, d] // because 90 degrees, draws right angle box
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-1, 4], [-4, 1]]" data-title="16. Complementary angles 2">
var a = [0, 0],
    b = polar(1, -40),
    c = polar(1, -10),
    d = polar(1, 5);

drawRay({
    points: [a, b]
});

drawRay({
    points: [a, c]
});

drawRay({
    points: [a, d]
});

drawAngleLabel({
    points: [b, a, c],
    label: "x",
    distance: 8,    // distance from vertex to label
    color: PINK,
    arcs: 2
});

drawAngleLabel({
    points: [c, a, d],
    label: "$deg0", // $deg is replaced by actual angle measure
    distance: 2,    // the 0 means 0 decimal places are shown
    color: PURPLE
});

drawAngleLabel({
    points: [b, a, d],
    label: "$deg0",
    distance: 18,
    color: BLUE,
    arcs: 3
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-2, 10], [-2, 6]]" data-title="17. Polygon">
drawPolygon({
    // This polygon has 4 points, but you can have much more!
    points: [
        [0, 0],
        [3, 4],
        [8, 4],
        [5, 0]    
    ],
    // All of the properties below can be either an array
    // (in which case each element applies to one angle/side/
    // vertex) or a single element (in which case it applies to
    // each angle/side/vertex)
    showPoints: true,     // whether to draw the actual vertices
    angleLabels: "$deg0", // angle measure in degrees, no decimals
    sideLabels: "$len0",  // side length in units, no decimals
    vertexLabels: ["A", "B", "C", "D"],
    arcs: [1, 2, 1, 2],     // number of angle arcs
    ticks: 1,               // number of side ticks
    arrows: [1, 2, 1, 2]    // number of side arrows
});
</script>

<script type="text/graphie" data-use-simple="true" data-title="18. Regular Polygon">
var n = 5; // number of sides

var angle = 2 * Math.PI / n;
var offset = (1 / n - 1 / 2) * Math.PI;
var radius = 12 / SQRT2;

var points = _.times(n, function(i) {
    return polar(radius, toDegrees(i * angle + offset)) ;
});

drawPolygon({
    points: points,
    arcs: 1,
    ticks: 1,
    stroke: PINK
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-1, 11], [-4, 7]]" data-title="19. Simple Figure">
drawPolygon({
    points: [[0, 0], [0, 3], [7, 3], [7, 0]],
    sideLabels: ["$len0"],
    fill: GREEN,
    fillOpacity: 0.2
});

drawPolygon({
    points: [[0, 3], [2, 6], [7, 3]],
    fill: GREEN,
    fillOpacity: 0.2
});

drawPolygon({
    points: [[0, 0], [7, 0], [10, -3]],
    sideLabels: ["$len0"],
    fill: GREEN,
    fillOpacity: 0.2
});

drawSegment({
   points: [[7, 0], [10, 0]],
   dashed: true
});

drawSegment({
   points: [[10, 0], [10, -3]],
   sideLabel: "$len0",
   dashed: true
});

drawAngleLabel({
    points: [[7, 0], [10, 0], [10, -3]]
});

drawSegment({
    points: [[2, 3], [2, 6]],
    dashed: true,
    sideLabel: "$len0"
});

drawAngleLabel({
    points: [[7, 3], [2, 3], [2, 6]]
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-5, 5], [-5, 5]]" data-title="20. Complex Figure">
var inner = 1.5;
inner /= 2;

var outer = 4;
outer -= inner;

var a = [-inner, -inner],
    b = [-inner,  inner],
    c = [ inner,  inner],
    d = [ inner, -inner];

drawPolygon({
    points: [
        d,
        a,
        b,
        [-outer, inner],
        [-outer, -outer],
        [inner, -outer]
    ],
    sideLabels: [,,,"$len0","$len0"],
    fill: GREEN,
    fillOpacity: 0.2
});

drawPolygon({
    points: [
        b,
        c,
        d,
        [outer, -inner],
        [outer, outer],
        [-inner, outer]
    ],
    sideLabels: [,,,"$len0","$len0"],
    fill: GREEN,
    fillOpacity: 0.2
});

var radius = outer - inner;

drawArc({
    center: b,
    radius: radius,
    start: 90,
    end: 180,
    fill: GREEN,
    fillOpacity: 0.2
});

drawArc({
    center: d,
    radius: radius,
    start: 270,
    end: 0,
    fill: GREEN,
    fillOpacity: 0.2
});


drawSegment({
    points: [
        b,
        addPoints(b, polar(radius, 135))
    ],
    sideLabel: "$len1",
    dashed: true
});

var middle = outer - (outer - inner) / 2;

drawSegment({
    points: [
        [middle, inner],
        [middle, -inner],
    ],
    sideLabel: "$len1",
    dashed: true
});

drawSegment({
    points: [
        [-inner, -middle],
        [inner, -middle]
    ],
    sideLabel: "$len1",
    dashed: true
});
</script>

<script type="text/graphie" data-use-simple="true" data-range="[[-2, 2], [-2, 2]]" data-title="21. 3D Example">
var color1 = "#D7ED3A";
var color2 = "#38C77F";
var color3 = "#78D0EF";
var color4 = "#F0B63A";
var height = 4;
var base = height * 2;
var side = "" + height + "\\sqrt{2}";
var depth = 3;
var xangle = PI / 15;
var yangle = -PI / 8;
var scale = 5;
var vertices = [
    [-1, 0.5, 1],
    [1, 0.5, 1],
    [0, -0.5, 1],
    [-1, 0.5, -1],
    [1, 0.5, -1],
    [0, -0.5, -1]
];
var faces = [
    {
        verts: [0, 2, 1],
        color: color3,
        lines: [[[0, -0.5, 1], [0, 0.5, 1]]],
        labels: [[[0, 0, 1], height]]
    }, {
        verts: [3, 4, 5],
        color: color3,
        lines: [[[-0.03, -0.47, -1], [0.95, 0.5, -1]]],
        labels: [[[0.2, -0.08, -1], side]]
    }, {
        verts: [0, 1, 4, 3],
        color: color4,
        lines: [[[1, 0.5, 0], [-1, 0.5, 0]]],
        labels: [[[0, 0.5, 0], base]]
    }, {
        verts: [1, 2, 5, 4],
        color: color1,
        lines: [[[0.5, 0, 1], [0.5, 0, -1]]],
        labels: [[[0.5, 0, 0], depth]]
    }, {
        verts: [0, 3, 5, 2],
        color: color2,
        lines: [[[-1, 0.5, 0], [0, -0.5, 0]]],
        labels: [[[-0.5, 0, 0], side]]
    }
];

var obj = make3dObject(vertices, {scale: scale});

_.each(faces, function(face) {
    obj.addFace(face);
});

obj.setPos([0, 0, 5]);
obj.rotate(1, 0, 0, yangle);
obj.rotate(0, 1, 0, xangle);
obj.doDraw();
</script>


<script type="text/graphie" data-use-simple="true" data-range="[[0, 11.5], [0, 9.5]]" data-title="22. Rectangular Prism Net">
/* Helper functions for drawing simple polygons            */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
var rotatePoints = function(center, angle, points) {
    return _.map(points, function(pt) {
        return rotatePoint(pt, angle, center);
    });
};

var drawSimpleRectangle = function(description) {
    var x = description.x || 0;
    var y = description.y || 0;
    var rotate = description.rotate || 0;
    var width  = description.width || 1;
    var height = description.height || 1;
    var showLabels = description.showLabels || false;

    var points = rotatePoints([x, y], rotate, [
            [x - width/2, y - height/2],
            [x - width/2, y + height/2],
            [x + width/2, y + height/2],
            [x + width/2, y - height/2]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [
            null,
            null,
            showLabels ? "$len0" : null,
            showLabels ? "$len0" : null
        ],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
};
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


var showLabels = true;

drawSimpleRectangle({
    x: 4,
    y: 5,
    width: 3,
    height: 4,
    showLabels: showLabels
});

drawSimpleRectangle({
    x: 1.5,
    y: 5,
    width: 2,
    height: 4,
    showLabels: showLabels,
    ticks: [3, 1, 3, 1]
});

drawSimpleRectangle({
    x: 6.5,
    y: 5,
    width: 2,
    height: 4,
    showLabels: showLabels,
    ticks: [3, 1, 3, 1]
});

drawSimpleRectangle({
    x: 4,
    y: 8,
    width: 3,
    height: 2,
    showLabels: showLabels,
    ticks: [1, 2, 1, 2]
});

drawSimpleRectangle({
    x: 4,
    y: 2,
    width: 3,
    height: 2,
    showLabels: showLabels,
    ticks: [1, 2, 1, 2]
});

drawSimpleRectangle({
    x: 9,
    y: 5,
    width: 3,
    height: 4,
    showLabels: showLabels,
    ticks: [3, 2, 3, 2]
});
</script>


<script type="text/graphie" data-use-simple="true" data-range="[[0, 11], [0, 11]]" data-title="23. Square Pyramid Net">
/* Helper functions for drawing simple polygons            */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
var triangleHeight = sqrt(3)/2;
var triangleOffset = triangleHeight/3;
var triangleBuffer = 1/2 - triangleOffset;

var rotatePoints = function(center, angle, points) {
    return _.map(points, function(pt) {
        return rotatePoint(pt, angle, center);
    });
};

var drawSimpleTriangle = function(description) {
    var x      = description.x || 0;
    var y      = description.y || 0;
    var rotate = description.rotate || 0;
    var base   = description.base || 1;
    var height = description.height || triangleHeight * base;
    var showLabels = description.showLabels || false;
    var centerOffset = description.centerOffset === undefined ?
            height/3 :
            description.centerOffset;

    var points = rotatePoints([x, y], rotate, [
        [x - base/2, y - centerOffset],
        [x, y + height - centerOffset],
        [x + base/2, y - centerOffset]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [null, null, showLabels ? "$len0" : null],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
    if (showLabels) {
        baseMidpoint = lineMidpoint([points[0], points[2]]);
        drawSegment({
            points: [points[1], baseMidpoint],
            dashed: true,
            sideLabel: "$len0"
        });
        drawAngleLabel({
            points: [points[1], baseMidpoint, points[0]]
        });
    }
};

var drawSimpleRectangle = function(description) {
    var x = description.x || 0;
    var y = description.y || 0;
    var rotate = description.rotate || 0;
    var width  = description.width || 1;
    var height = description.height || 1;
    var showLabels = description.showLabels || false;

    var points = rotatePoints([x, y], rotate, [
            [x - width/2, y - height/2],
            [x - width/2, y + height/2],
            [x + width/2, y + height/2],
            [x + width/2, y - height/2]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [
            null,
            null,
            showLabels ? "$len0" : null,
            showLabels ? "$len0" : null
            ],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
};
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


drawSimpleRectangle({
    x: 5.5,
    y: 5.5,
    width: 3,
    height: 3,
    showLabels: true
});

drawSimpleTriangle({
    x: 5.5,
    y: 7,
    base: 3,
    height: 4,
    rotate: 0,
    ticks: [2, 2, 1],
    centerOffset: 0,
    showLabels: true
});


drawSimpleTriangle({
    x: 4,
    y: 5.5,
    base: 3,
    height: 4,
    rotate: 90,
    ticks: [2, 2, 1],
    centerOffset: 0
});

drawSimpleTriangle({
    x: 7,
    y: 5.5,
    base: 3,
    height: 4,
    rotate: -90,
    ticks: [2, 2, 1],
    centerOffset: 0
});

drawSimpleTriangle({
    x: 5.5,
    y: 4,
    base: 3,
    height: 4,
    rotate: 180,
    ticks: [2, 2, 1],
    centerOffset: 0
});
</script>


<script type="text/graphie" data-use-simple="true" data-range="[[0, 4], [0, 6.5]]" data-title="24. Triangular Prism Net">
/* Helper functions for drawing simple polygons            */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
var triangleHeight = sqrt(3)/2;
var triangleOffset = triangleHeight/3;
var triangleBuffer = 1/2 - triangleOffset;

var rotatePoints = function(center, angle, points) {
    return _.map(points, function(pt) {
        return rotatePoint(pt, angle, center);
    });
};

var drawSimpleTriangle = function(description) {
    var x      = description.x || 0;
    var y      = description.y || 0;
    var rotate = description.rotate || 0;
    var base   = description.base || 1;
    var height = description.height || triangleHeight * base;
    var showLabels = description.showLabels || false;
    var centerOffset = description.centerOffset === undefined ?
            height/3 :
            description.centerOffset;

    var points = rotatePoints([x, y], rotate, [
        [x - base/2, y - centerOffset],
        [x, y + height - centerOffset],
        [x + base/2, y - centerOffset]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [null, null, showLabels ? "$len0" : null],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
    if (showLabels) {
        baseMidpoint = lineMidpoint([points[0], points[2]]);
        drawSegment({
            points: [points[1], baseMidpoint],
            dashed: true,
            sideLabel: "$len0"
        });
        drawAngleLabel({
            points: [points[1], baseMidpoint, points[0]]
        });
    }
};

var drawSimpleRectangle = function(description) {
    var x = description.x || 0;
    var y = description.y || 0;
    var rotate = description.rotate || 0;
    var width  = description.width || 1;
    var height = description.height || 1;
    var showLabels = description.showLabels || false;

    var points = rotatePoints([x, y], rotate, [
            [x - width/2, y - height/2],
            [x - width/2, y + height/2],
            [x + width/2, y + height/2],
            [x + width/2, y - height/2]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [
            null,
            null,
            showLabels ? "$len0" : null,
            showLabels ? "$len0" : null
        ],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
};
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


var showLabels = false;

var lowerTriangleCenter = [3, 2.5];
var lowerRectCenter = [3, 1 + triangleBuffer];

var midRectCenter = rotatePoint(lowerRectCenter, -120, lowerTriangleCenter);
var upperTriangleCenter = rotatePoint(lowerTriangleCenter, 180, midRectCenter);
var upperRectCenter = rotatePoint(midRectCenter, 120, upperTriangleCenter);

drawSimpleRectangle({
    x: lowerRectCenter[0],
    y: lowerRectCenter[1],
    width: 1,
    height: 2,
    showLabels: showLabels,
    ticks: [2, 1, 2, 1]
});

drawSimpleTriangle({
    x: lowerTriangleCenter[0],
    y: lowerTriangleCenter[1],
    base: 1,
    showLabels: showLabels,
    ticks: [1, 1, 1]
});


drawSimpleRectangle({
    x: midRectCenter[0],
    y: midRectCenter[1],
    width: 1,
    height: 2,
    rotate: -120,
    showLabels: showLabels,
    ticks: [2, 1, 2, 1]
});

drawSimpleTriangle({
    x: upperTriangleCenter[0],
    y: upperTriangleCenter[1],
    base: 1,
    rotate: 180,
    showLabels: showLabels,
    ticks: [1, 1, 1]
});

drawSimpleRectangle({
    x: upperRectCenter[0],
    y: upperRectCenter[1],
    width: 1,
    height: 2,
    showLabels: showLabels,
    ticks: [2, 1, 2, 1]
});

/* a rectangle attached to the right side of the lower triangle  */
/*
var rightRectCenter = rotatePoint(lowerRectCenter, 120, lowerTriangleCenter);
drawSimpleRectangle({
    x: rightRectCenter[0],
    y: rightRectCenter[1],
    width: 1,
    height: 2,
    rotate: 120,
    showLabels: showLabels,
    ticks: [2, 1, 2, 1]
});
*/
</script>


<script type="text/graphie" data-use-simple="true" data-range="[[0, 6], [0, 5]]" data-title="25. Tetrahedron Net">
/* Helper functions for drawing simple polygons            */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
var triangleHeight = sqrt(3)/2;
var triangleOffset = triangleHeight/3;
var triangleBuffer = 1/2 - triangleOffset;

var rotatePoints = function(center, angle, points) {
    return _.map(points, function(pt) {
        return rotatePoint(pt, angle, center);
    });
};

var drawSimpleTriangle = function(description) {
    var x      = description.x || 0;
    var y      = description.y || 0;
    var rotate = description.rotate || 0;
    var base   = description.base || 1;
    var height = description.height || triangleHeight * base;
    var showLabels = description.showLabels || false;
    var centerOffset = description.centerOffset === undefined ?
            height/3 :
            description.centerOffset;

    var points = rotatePoints([x, y], rotate, [
        [x - base/2, y - centerOffset],
        [x, y + height - centerOffset],
        [x + base/2, y - centerOffset]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [null, null, showLabels ? "$len0" : null],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
    if (showLabels) {
        baseMidpoint = lineMidpoint([points[0], points[2]]);
        drawSegment({
            points: [points[1], baseMidpoint],
            dashed: true,
            sideLabel: "$len0"
        });
        drawAngleLabel({
            points: [points[1], baseMidpoint, points[0]]
        });
    }
};
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


/* since our triangles have side length 2 */
var offset = 2 * triangleOffset;

drawSimpleTriangle({
    x: 3,
    y: 3,
    base: 2,
    rotate: 0
});

drawSimpleTriangle({
    x: 2,
    y: 3 + offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 4,
    y: 3 + offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 3,
    y: 3 - 2 * offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});
</script>


<script type="text/graphie" data-use-simple="true" data-range="[[0, 6], [0, 8]]" data-title="26. Octahedron Net">
/* Helper functions for drawing simple polygons            */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
var triangleHeight = sqrt(3)/2;
var triangleOffset = triangleHeight/3;
var triangleBuffer = 1/2 - triangleOffset;

var rotatePoints = function(center, angle, points) {
    return _.map(points, function(pt) {
        return rotatePoint(pt, angle, center);
    });
};

var drawSimpleTriangle = function(description) {
    var x      = description.x || 0;
    var y      = description.y || 0;
    var rotate = description.rotate || 0;
    var base   = description.base || 1;
    var height = description.height || triangleHeight * base;
    var showLabels = description.showLabels || false;
    var centerOffset = description.centerOffset === undefined ?
            height/3 :
            description.centerOffset;

    var points = rotatePoints([x, y], rotate, [
        [x - base/2, y - centerOffset],
        [x, y + height - centerOffset],
        [x + base/2, y - centerOffset]
    ]);

    drawPolygon({
        points: points,
        angleLabels: [],
        sideLabels: [null, null, showLabels ? "$len0" : null],
        ticks: description.ticks,
        fill: GREEN,
        fillOpacity: 0.2
    });
    if (showLabels) {
        baseMidpoint = lineMidpoint([points[0], points[2]]);
        drawSegment({
            points: [points[1], baseMidpoint],
            dashed: true,
            sideLabel: "$len0"
        });
        drawAngleLabel({
            points: [points[1], baseMidpoint, points[0]]
        });
    }
};
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


/* since our triangles have side length 2 */
var offset = 2 * triangleOffset;
var height = 2 * triangleHeight;

drawSimpleTriangle({
    x: 3,
    y: 4 + offset,
    base: 2,
    rotate: 0,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 2,
    y: 4 + 2 * offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 4,
    y: 4 + 2 * offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 3,
    y: 4 - offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 2,
    y: 4 - 2 * offset,
    base: 2,
    rotate: 0,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 4,
    y: 4 - 2 * offset,
    base: 2,
    rotate: 0,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 2,
    y: 4 - height - offset,
    base: 2,
    rotate: 180,
    ticks: [1, 1, 1]
});

drawSimpleTriangle({
    x: 4,
    y: 4 + height + offset,
    base: 2,
    rotate: 0,
    ticks: [1, 1, 1]
});
</script>


<script type="text/graphie" data-title="27. Box Plot">
// For an interactive example, see:
// khan-exercises/exercises/creating_box_and_whisker_plots.html

/* Number line parameters */
var numberLineMin = 0;
var numberLineMax = 15;
var numberLineTickSize = 1;

/* Data distribution parameters */
var q0 = 2.5;
var q1 = 4;
var median = 5.5;
var q3 = 8;
var q4 = 11;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Normalize points to the size of the canvas, and set up  */
/* the canvas                                              */
var numberLineSpread = numberLineMax - numberLineMin;
var numberLineTickCount = numberLineSpread/numberLineTickSize;
var xrange = [ -0.5, numberLineTickCount + 0.5 ];

init({
    range: [xrange, [ -3.5, 1.5 ]],
    scale: _.min([30, Perseus.Util.scaleFromExtent(xrange, 480)])
});
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

var normalize = function(number) {
    return ((number - numberLineMin) / numberLineSpread) *
        numberLineTickCount;
};
var denormalize = function(position) {
    return position * numberLineSpread / numberLineTickCount +
        numberLineMin;
};

/* Draw the number line */
line([ 0, -2 ], [ numberLineTickCount, -2 ]);
for (tick = 0; tick <= numberLineTickCount; tick+=1) {
    var tickValue = denormalize(tick);
    line([ tick, -1.75 ], [ tick, -2.25 ]);
    label([ tick, -2.25 ], roundTo(1, tickValue), "below");
}

var nq0 = normalize(q0);
var nq1 = normalize(q1);
var nmedian = normalize(median);
var nq3 = normalize(q3);
var nq4 = normalize(q4);

// draw Q0
drawPoint({point: [nq0, 0]});

// draw Q1
drawSegment({points: [[nq1, -1], [nq1, 1]]});

// draw median
drawSegment({points: [[nmedian, 1], [nmedian, -1]]});

// draw Q3
drawSegment({points: [[nq3, -1], [nq3, 1]]});

// draw Q4
drawPoint({point: [nq4, 0]});

// draw connecting lines
drawSegment({points: [[nq0, 0], [nq1, 0]]});
drawSegment({points: [[nq1, 1], [nq3, 1]]});
drawSegment({points: [[nq1, -1], [nq3, -1]]});
drawSegment({points: [[nq3, 0], [nq4, 0]]});
</script>

<script type="text/graphie" data-title="28. Dot Plot">
/* Variables */
var min = 0;            // number line start
var max = 10;           // number line end

var labelInterval = 1;  // interval at which line will be labeled
var tickInterval = 1/4; // interval at which ticks will be drawn

var color = BLUE;       // dot color

/* Data */
var data = {
    // x: y
    0.25: 1,
    2.00: 3,
    2.25: 2,
    4.00: 3,
    4.50: 6,
    4.75: 2,
    6.00: 2,
    8.25: 1,
    9.50: 2
};

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* You almost certainly don't need to edit anything below. */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

var xSpacing = 0.5;     // distance between tick marks
var ySpacing = 0.75;    // distance between dots

var tickHeight = 0.5;   // tick mark height
var linePosition = -1;  // number line y position

var spread = max - min;
var tickCount = Math.floor(spread / tickInterval);
var labelCount = Math.floor(spread / labelInterval);

/* Ignore data outside number line bounds */
var inRange = function(x) { return x >= min && x <= max; };
data = _.pick(data, _.filter(_.keys(data), inRange));

var xOffset = tickCount >= 48 ? 1 : 0.5;
var yOffset = tickCount > 60 ? 3.5 : (tickCount > 40 ? 3 : 2.5);

var xRange = [-xOffset, tickCount * xSpacing + xOffset];
var yRange = [-yOffset, _.max(data) * ySpacing];

/* Prevent width from exceeding 480 pixels */
init({
    range: [xRange, yRange],
    scale: _.min([30, Perseus.Util.scaleFromExtent(xRange, 480)])
});

var normalize = function(number) {
    return ((number - min) / spread) * tickCount;
};
var denormalize = function(position) {
    return position * spread / labelCount + min;
};

/* Draw the number line */
line(
    [0, linePosition],
    [tickCount * xSpacing, linePosition]
);

/* Draw the ticks */
_.times(tickCount + 1, function(i) {
    line(
        [i * xSpacing, linePosition + tickHeight / 2],
        [i * xSpacing, linePosition - tickHeight / 2]
    );
});

/* Draw the labels */
_.times(labelCount + 1, function(i) {
    var factor = labelInterval / tickInterval;

    // If there are more than 2 ticks per label, emphasize one
    // of the ticks to make it easier to distinguish visually
    if (factor > 2) {
        line(
            [i * xSpacing * factor, linePosition + tickHeight],
            [i * xSpacing * factor, linePosition - tickHeight]
        );        
    }

    label(
        [i * xSpacing * factor, linePosition - tickHeight],
        denormalize(i),
        "below"
    );
});

/* Draw the data */
_.each(data, function(y, x) {
    _.times(y, function(j) {
        drawPoint({
            point: [normalize(x) * xSpacing, j * ySpacing],
            color: color
        }); 
    });
});
</script>
</div>


<div id="controls">
<input type="button" value="Regraph" class="btn-rerender">
<form action="/png" target="_blank" method="POST" class="form-create-png">
<input type="hidden" name="js">
<input type="submit" value="Convert to Image">
</form>
</div>
</div>

<div id="output">
<div class="graphie">
</div>
<span class="size">
</span>
</div>

{% endblock content %}

{% block scripts %}

{{super()}}
<script src="/static/js/ace/ace.js" type="text/javascript" charset="utf-8"></script>

<script>
(function() {
    var editor = ace.edit("editor");
    var session = editor.getSession();

    var $samples = $("#samples").children();
    var $sampleSelect = $("<select>").appendTo("#controls");
    var gridSetupPre = $("#grid-setup-pre").html();
    var gridSetupPost = $("#grid-setup-post").html();
    var simpleSetupPre = $("#simple-setup-pre").html();
    var simpleSetupPost = $("#simple-setup-post").html();
    var samples = _.map($samples, function(el, i) {
        var $el = $(el);
        var code = $el.html();
        if ($el.data("use-grid")) {
            code = gridSetupPre + code + gridSetupPost;
        }
        if ($el.data("use-simple")) {
            var range = $el.attr("data-range") || "[[-10, 10], [-10, 10]]";
            code = simpleSetupPre.replace("RANGE", range) + code + simpleSetupPost;
        }
        var sample = {
            title: $el.data("title"),
            js: $.trim(code) + "\n"
        };
        $("<option>")
                .val(i).text(sample.title)
                .data("js", sample.js)
                .appendTo($sampleSelect);
        return sample;
    });

    var sampleJS = samples[0].js;
    session.setValue(sampleJS);

    // $(window).on("beforeunload", function() {
    //     if (session.getValue() !== sampleJS) {
    //         return "All modifications will be lost.";
    //     }
    // });

    $sampleSelect.val(0).on("change", function() {
        var i = +$(this).val();
        sampleJS = samples[i].js;
        editor.setValue(sampleJS, /* cursorPos: */ -1);
        updateGraphie();
    });

    session.setMode("ace/mode/javascript");
    session.setUseWrapMode(true);

    var isMac = (/mac/i).test(navigator.platform);
    $(document).on("keydown", function(e) {
        if (e.keyCode === "R".charCodeAt(0) &&
                (e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey) {
            e.preventDefault();
            updateGraphie();
        } else if (e.keyCode === 8) { // Backspace
            var message = "Are you sure you want to leave the page?";
            var leave = window.confirm(message);
            if (!leave) {
                e.preventDefault();
            }
        }
    });
    $(".btn-rerender")
            .val(function() {
                if (isMac) {
                    return "Regraph (\u2318R)";
                } else {
                    return "Regraph (Ctrl-R)";
                }
            })
            .on("click", updateGraphie);
    updateGraphie();

    $(".form-create-png").on("submit", function() {
        var $form = $(this);
        $form.find("input[type=hidden]").val(editor.getValue());
    });

    function updateGraphie() {
        try {
            $("#output > div")
                    .data("graphie", null)
                    .removeClass("error")
                    .text(editor.getValue()).graphie();
            $("#output > .size")
                    .empty()
                    .text($(".graphie").width() + " x " + $(".graphie").height());

        } catch (e) {
            $("#output > div")
                    .addClass("error")
                    .text(e.name + ": " + e.message);
            $("#output > .size").empty();
        }
    }
})();
</script>

{% endblock scripts %}
